<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Space Arc</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: url("Arc.png") center/cover no-repeat;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      resetPlayerPosition();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Images
    const playerImg = new Image();
    playerImg.src = "k.png";

    const meteorImg = new Image();
    meteorImg.src = "p.png";

    const bonusImg = new Image();
    bonusImg.src = "u.png";

    // Player (bigger size)
    const player = {
      x: 0,
      y: 0,
      w: 130,  // bigger
      h: 130,  // bigger
      speed: 7
    };

    function resetPlayerPosition() {
      player.x = canvas.width / 2 - player.w / 2;
      player.y = canvas.height - player.h - 40;
    }

    // Game state
    let meteors = [];
    let bonuses = [];
    let score = 0;
    let collected = 0;
    let gameOver = false;
    let started = false;
    let win = false;

    const TARGET_BONUSES = 20;

    // Simple frame-based spawn timers
    let meteorTimer = 0;
    let bonusTimer = 0;
    const METEOR_INTERVAL_FRAMES = 55;
    const BONUS_INTERVAL_FRAMES  = 160;

    const MAX_METEORS = 10;
    const MAX_BONUSES = 5;

    // Meteor acceleration
    let meteorSpeedBoost = 0;             // grows over time
    const METEOR_BOOST_PER_FRAME = 0.002; // very soft
    const METEOR_MAX_SPEED = 12;

    // Explosion flash (for all meteors)
    let explosionFlashFrames = 0;

    // Keyboard
    const keys = new Set();

    window.addEventListener("keydown", (e) => {
      keys.add(e.code);
      if (!started && e.code === "Space") started = true;
      if ((gameOver || win) && e.code === "Space") resetGame();
    });

    window.addEventListener("keyup", (e) => keys.delete(e.code));

    // Click start / restart
    canvas.addEventListener("click", () => {
      if (!started) {
        started = true;
      } else if (gameOver || win) {
        resetGame();
      }
    });

    function clampPlayer() {
      if (player.x < 0) player.x = 0;
      if (player.y < 0) player.y = 0;
      if (player.x + player.w > canvas.width) player.x = canvas.width - player.w;
      if (player.y + player.h > canvas.height) player.y = canvas.height - player.h;
    }

    function spawnMeteor() {
      if (meteors.length >= MAX_METEORS) return;
      const size = Math.max(60, canvas.width * 0.07);
      const x = Math.random() * (canvas.width - size);
      const y = -size - 20;
      const baseVy = 4 + Math.random() * 3;
      const vy = Math.min(METEOR_MAX_SPEED, baseVy + meteorSpeedBoost);
      meteors.push({ x, y, w: size, h: size, vy });
    }

    function spawnBonus() {
      if (bonuses.length >= MAX_BONUSES) return;
      const size = Math.max(50, canvas.width * 0.06);
      const x = Math.random() * (canvas.width - size);
      const y = -size - 20;
      const vy = 3 + Math.random() * 2;
      bonuses.push({ x, y, w: size, h: size, vy });
    }

    function intersects(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function update() {
      if (!started || gameOver || win) return;

      // Player movement (fixed step)
      const step = player.speed;
      if (keys.has("ArrowLeft") || keys.has("KeyA")) player.x -= step;
      if (keys.has("ArrowRight") || keys.has("KeyD")) player.x += step;
      if (keys.has("ArrowUp") || keys.has("KeyW")) player.y -= step;
      if (keys.has("ArrowDown") || keys.has("KeyS")) player.y += step;
      clampPlayer();

      // Meteor global speed boost
      meteorSpeedBoost += METEOR_BOOST_PER_FRAME;
      if (meteorSpeedBoost > 8) meteorSpeedBoost = 8;

      // Spawning (by frames)
      meteorTimer++;
      bonusTimer++;

      if (meteorTimer >= METEOR_INTERVAL_FRAMES) {
        meteorTimer = 0;
        spawnMeteor();
      }

      if (bonusTimer >= BONUS_INTERVAL_FRAMES) {
        bonusTimer = 0;
        spawnBonus();
      }

      // Move meteors
      for (const m of meteors) {
        m.vy = Math.min(METEOR_MAX_SPEED, m.vy + 0.01); // little acceleration
        m.y += m.vy;
      }

      // Move bonuses
      for (const b of bonuses) {
        b.y += b.vy;
      }

      // Remove off-screen
      meteors = meteors.filter(m => m.y < canvas.height + 120);
      bonuses = bonuses.filter(b => b.y < canvas.height + 120);

      // Meteor collisions → lose
      for (const m of meteors) {
        if (intersects(player, m)) {
          gameOver = true;
          break;
        }
      }

      // Bonus collisions → +bonus, all meteors explode + clear
      for (let i = bonuses.length - 1; i >= 0; i--) {
        const b = bonuses[i];
        if (intersects(player, b)) {
          score += 10;
          collected++;
          bonuses.splice(i, 1);

          // Trigger flash explosion for all meteors
          if (meteors.length > 0) {
            explosionFlashFrames = 12; // short flash
          }
          meteors = []; // remove all meteors

          // Win condition
          if (collected >= TARGET_BONUSES) {
            win = true;
          }
        }
      }

      // Decrease explosion flash
      if (explosionFlashFrames > 0) {
        explosionFlashFrames--;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Meteors
      for (const m of meteors) {
        if (meteorImg.complete) {
          ctx.drawImage(meteorImg, m.x, m.y, m.w, m.h);
        } else {
          ctx.fillStyle = "rgba(255,80,80,0.8)";
          ctx.fillRect(m.x, m.y, m.w, m.h);
        }
      }

      // Bonuses
      for (const b of bonuses) {
        if (bonusImg.complete) {
          ctx.drawImage(bonusImg, b.x, b.y, b.w, b.h);
        } else {
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(b.x + b.w/2, b.y + b.h/2, Math.min(b.w,b.h)/2, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // Player
      if (playerImg.complete) {
        ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = "#00ffff";
        ctx.fillRect(player.x, player.y, player.w, player.h);
      }

      // Flash explosion overlay
      if (explosionFlashFrames > 0) {
        const alpha = explosionFlashFrames / 12;
        ctx.fillStyle = "rgba(255, 220, 120," + alpha + ")";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // HUD
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(10, 10, 280, 80);
      ctx.fillStyle = "#fff";
      ctx.font = "20px Arial";
      ctx.fillText("Space Arc", 20, 35);
      ctx.fillText("Score: " + score, 20, 60);
      ctx.fillText("Bonuses: " + collected + " / " + TARGET_BONUSES, 20, 85);

      // Start overlay
      if (!started && !gameOver && !win) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "44px Arial Black";
        ctx.textAlign = "center";
        ctx.fillText("Space Arc", canvas.width / 2, canvas.height / 2 - 40);
        ctx.font = "24px Arial";
        ctx.fillText("Press SPACE or CLICK to start", canvas.width / 2, canvas.height / 2 + 5);
        ctx.fillText("Move with arrows / WASD", canvas.width / 2, canvas.height / 2 + 40);
        ctx.textAlign = "left";
      }

      // Game over overlay
      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "46px Arial Black";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 40);
        ctx.font = "26px Arial";
        ctx.fillText("Score: " + score + "   Bonuses: " + collected,
                     canvas.width / 2, canvas.height / 2 + 5);
        ctx.fillText("Press SPACE or CLICK to restart", canvas.width / 2, canvas.height / 2 + 45);
        ctx.textAlign = "left";
      }

      // Win overlay — glow of victory ✨
      if (win) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const maxR = Math.max(canvas.width, canvas.height) * 0.8;

        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
        gradient.addColorStop(0, "rgba(160, 255, 230, 0.95)");
        gradient.addColorStop(0.4, "rgba(90, 210, 255, 0.7)");
        gradient.addColorStop(1, "rgba(0, 0, 0, 0.9)");

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ffffff";
        ctx.font = "52px Arial Black";
        ctx.textAlign = "center";
        ctx.fillText("YOU WIN!", canvas.width / 2, canvas.height / 2 - 20);
        ctx.font = "26px Arial";
        ctx.fillText("Bonuses collected: " + collected, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText("Press SPACE or CLICK to play again", canvas.width / 2, canvas.height / 2 + 60);
        ctx.textAlign = "left";
      }
    }

    function resetGame() {
      resetPlayerPosition();
      meteors = [];
      bonuses = [];
      score = 0;
      collected = 0;
      gameOver = false;
      win = false;
      meteorSpeedBoost = 0;
      meteorTimer = 0;
      bonusTimer = 0;
      explosionFlashFrames = 0;
      started = true;
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
