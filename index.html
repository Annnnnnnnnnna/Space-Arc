<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Space Arc</title>
  <style>
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: url("Arc.png") center/cover no-repeat; /* full-screen background */
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Adjust canvas to full window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // Images
    const playerImg = new Image();
    playerImg.src = "k.png";

    const meteorImg = new Image();
    meteorImg.src = "p.png";

    const bonusImg = new Image();
    bonusImg.src = "u.png";

    // Game state
    const player = {
      x: canvas.width / 2 - 50,
      y: canvas.height - 150,
      w: 100,
      h: 100,
      speed: 8
    };

    let meteors = [];
    let bonuses = [];
    let lastMeteorTime = 0;
    let lastBonusTime = 0;
    let score = 0;
    let collected = 0;
    let gameOver = false;
    let started = false;

    // Input
    const keys = new Set();

    window.addEventListener("keydown", (e) => {
      keys.add(e.code);
      if (!started && e.code === "Space") {
        started = true;
      }
    });

    window.addEventListener("keyup", (e) => {
      keys.delete(e.code);
    });

    // Pointer (mouse / touch) control
    let dragging = false;

    canvas.addEventListener("pointerdown", (e) => {
      if (gameOver) {
        resetGame();
        return;
      }
      if (!started) started = true;
      dragging = true;
      movePlayerToPointer(e);
    });

    canvas.addEventListener("pointermove", (e) => {
      if (dragging) {
        movePlayerToPointer(e);
      }
    });

    canvas.addEventListener("pointerup", () => {
      dragging = false;
    });
    canvas.addEventListener("pointercancel", () => {
      dragging = false;
    });

    function movePlayerToPointer(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      player.x = x - player.w / 2;
      player.y = y - player.h / 2;
      clampPlayer();
    }

    function clampPlayer() {
      if (player.x < 0) player.x = 0;
      if (player.y < 0) player.y = 0;
      if (player.x + player.w > canvas.width) player.x = canvas.width - player.w;
      if (player.y + player.h > canvas.height) player.y = canvas.height - player.h;
    }

    // Spawning
    function spawnMeteor() {
      const size = Math.max(50, canvas.width * 0.06);
      const x = Math.random() * (canvas.width - size);
      const y = -size - 20;
      const vy = 5 + Math.random() * 4; // falling speed
      meteors.push({ x, y, w: size, h: size, vy });
    }

    function spawnBonus() {
      const size = Math.max(40, canvas.width * 0.05);
      const x = Math.random() * (canvas.width - size);
      const y = -size - 20;
      const vy = 3 + Math.random() * 3;
      bonuses.push({ x, y, w: size, h: size, vy });
    }

    // Collision (axis-aligned rectangles)
    function intersects(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    // Update
    let lastTime = 0;

    function update(timestamp) {
      const dt = (timestamp - lastTime) || 16;
      lastTime = timestamp;

      if (!started || gameOver) {
        draw(); // draw static frame with overlay
        requestAnimationFrame(update);
        return;
      }

      // Player movement (keyboard)
      const step = player.speed * (dt / 16);
      if (keys.has("ArrowLeft") || keys.has("KeyA")) player.x -= step;
      if (keys.has("ArrowRight") || keys.has("KeyD")) player.x += step;
      if (keys.has("ArrowUp") || keys.has("KeyW")) player.y -= step;
      if (keys.has("ArrowDown") || keys.has("KeyS")) player.y += step;
      clampPlayer();

      // Spawn meteors
      if (timestamp - lastMeteorTime > 700) {
        lastMeteorTime = timestamp;
        spawnMeteor();
      }

      // Spawn bonuses
      if (timestamp - lastBonusTime > 2000) {
        lastBonusTime = timestamp;
        if (Math.random() < 0.7) { // sometimes skip, щоб не було занадто багато
          spawnBonus();
        }
      }

      // Move meteors
      for (const m of meteors) {
        m.y += m.vy * (dt / 16);
      }

      // Move bonuses
      for (const b of bonuses) {
        b.y += b.vy * (dt / 16);
      }

      // Remove off-screen objects
      meteors = meteors.filter(m => m.y < canvas.height + 100);
      bonuses = bonuses.filter(b => b.y < canvas.height + 100);

      // Check meteor collisions → game over
      for (const m of meteors) {
        if (intersects(player, m)) {
          gameOver = true;
          break;
        }
      }

      // Check bonus collisions → +score
      for (let i = bonuses.length - 1; i >= 0; i--) {
        if (intersects(player, bonuses[i])) {
          score += 10;
          collected += 1;
          bonuses.splice(i, 1);
        }
      }

      draw();
      requestAnimationFrame(update);
    }

    // Draw
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw meteors
      for (const m of meteors) {
        if (meteorImg.complete) {
          ctx.drawImage(meteorImg, m.x, m.y, m.w, m.h);
        } else {
          ctx.fillStyle = "rgba(255, 80, 80, 0.8)";
          ctx.fillRect(m.x, m.y, m.w, m.h);
        }
      }

      // Draw bonuses
      for (const b of bonuses) {
        if (bonusImg.complete) {
          ctx.drawImage(bonusImg, b.x, b.y, b.w, b.h);
        } else {
          ctx.fillStyle = "gold";
          ctx.beginPath();
          ctx.arc(b.x + b.w / 2, b.y + b.h / 2, Math.min(b.w, b.h) / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Draw player
      if (playerImg.complete) {
        ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = "#00ffff";
        ctx.fillRect(player.x, player.y, player.w, player.h);
      }

      // HUD
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(10, 10, 220, 70);
      ctx.fillStyle = "#ffffff";
      ctx.font = "20px Arial";
      ctx.fillText("Space Arc", 20, 35);
      ctx.fillText("Score: " + score, 20, 60);
      ctx.fillText("Bonuses: " + collected, 120, 60);

      // Start prompt
      if (!started && !gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ffffff";
        ctx.font = "40px Arial Black";
        ctx.textAlign = "center";
        ctx.fillText("Space Arc", canvas.width / 2, canvas.height / 2 - 40);
        ctx.font = "24px Arial";
        ctx.fillText("Press Space or Click to start", canvas.width / 2, canvas.height / 2 + 10);
        ctx.textAlign = "left";
      }

      // Game over overlay
      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ffffff";
        ctx.font = "46px Arial Black";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 40);
        ctx.font = "26px Arial";
        ctx.fillText("Score: " + score + "   Bonuses: " + collected,
                     canvas.width / 2, canvas.height / 2 + 5);
        ctx.fillText("Click to restart", canvas.width / 2, canvas.height / 2 + 45);
        ctx.textAlign = "left";
      }
    }

    // Restart on click when game over
    canvas.addEventListener("click", () => {
      if (!started) {
        started = true;
        return;
      }
      if (gameOver) {
        resetGame();
      }
    });

    function resetGame() {
      player.x = canvas.width / 2 - player.w / 2;
      player.y = canvas.height - 150;
      meteors = [];
      bonuses = [];
      score = 0;
      collected = 0;
      gameOver = false;
      started = true;
    }

    // Start loop
    requestAnimationFrame(update);
  </script>
</body>
</html>

